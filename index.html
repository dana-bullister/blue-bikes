<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Blue Bikes</title>
  <script src="https://d3js.org/d3.v6.js"></script>
</head>

<body>

  <!-- div that will contain visualization -->
  <div id="chart_area"></div>

  <script>
    // function to generate a scatter plot, given the name of an accessible csv
    // file with appropriately formatted data
    function generateScatterAnim(csvFileName, animate) {

      // define a parser for parsing csv columns representing datetimes (but
      // formatted as strings) as the appropriate date objects
      let parseDatetime = d3.timeParse("%Y-%m-%d %H:%M:%S");

      // define a datetime formatter for formmatting a date object in a way that is
      // cleanly readable as a date (specifically, "June 30, 2015")
      let formatDatetime = d3.timeFormat("%A, %B %d, %Y");

      // infer the month the bike data is describing based on the file name and
      // store this as a set of useful variables
      let bikeDataYear = csvFileName.substring(0, 4); // e.g., "2019"
      let bikeDataMonth = csvFileName.substring(4, 6); // e.g., "09"
      let bikeDataDateStr = bikeDataYear + '-' + bikeDataMonth + '-01'; // set it to start of month
      let bikeDataDatetimeStr = bikeDataDateStr + ' 00:00:00';
      let bikeDataDate = parseDatetime(bikeDataDatetimeStr);

      let monthNames = ["January", "February", "March", "April", "May", "June",
        "July", "August", "September", "October", "November", "December"
      ];
      let bikeDataMonthName = monthNames[bikeDataDate.getMonth()];

      // set padding and spacing
      let chart_area_padding = {
          top: 70,
          right: 30,
          bottom: 70,
          left: 65
        },

        chart_area_width = 460,
        chart_area_height = 400,
        graph_width = chart_area_width - chart_area_padding.left - chart_area_padding.right,
        graph_height = chart_area_height - chart_area_padding.top - chart_area_padding.bottom;

      // set min and max values for axes
      let secondDay = new Date(); // variable for the second day of the month
      secondDay.setTime(bikeDataDate);
      secondDay.setDate(2);

      let x_val_min = bikeDataDate,
        x_val_max = secondDay,
        y_val_min = 0,
        y_val_max = 120;

      let chart_area = d3.select("#chart_area")
        .attr("id", "chart_area")

      // add chart background
      let chart_background = chart_area
        .append("svg")
        .attr("id", "chart_background")
        .attr("width", chart_area_width)
        .attr("height", chart_area_height)
        .attr("style", "background: lightgrey");

      // add chart title
      chart_background.append("text")
        .attr("text-anchor", "middle")
        .attr("x", (graph_width / 2) + chart_area_padding.left)
        .attr("y", 30)
        .text("Bluebike Trip Duration By Time Of Day");

      // add chart subtitle
      chart_background.append("text")
        .attr("text-anchor", "middle")
        .attr("x", (graph_width / 2) + chart_area_padding.left)
        .attr("y", 50)
        .attr("font-size", 11)
        .text("(All  Rides in Boston, Cambridge, Brookline, Somerville for a Typical Day in " + bikeDataMonthName + ")");

      // add x-axis label
      chart_background.append("text")
        .attr("text-anchor", "middle")
        .attr("x", (graph_width / 2) + chart_area_padding.left)
        .attr("y", graph_height + chart_area_padding.top + 56)
        .text("Trip Start Time");

      // add y-axis label
      chart_background.append("text")
        .attr("text-anchor", "middle")
        .attr("transform", "rotate(-90)")
        .attr("y", chart_area_padding.left / 2 - 5)
        .attr("x", -chart_area_padding.top - graph_height / 2)
        .text("Trip Duration (Minutes)")

      // add  group that will contain chart elements
      let graph_elems = chart_background
        .append("g")
        .attr("id", "graph_elems")
        .attr("transform", "translate(" + chart_area_padding.left + "," + chart_area_padding.top + ")");

      // read data
      d3.csv(csvFileName).then((bike_data) => {

          // add x axis
          let x = d3.scaleLinear()
            .domain([x_val_min, x_val_max])
            .range([0, graph_width]);

          // specify where want x-axis tick marks placed
          let x_axis_ticks = [
            new Date(bikeDataDateStr + ' 02:00:00'),
            new Date(bikeDataDateStr + ' 04:00:00'),
            new Date(bikeDataDateStr + ' 06:00:00'),
            new Date(bikeDataDateStr + ' 08:00:00'),
            new Date(bikeDataDateStr + ' 10:00:00'),
            new Date(bikeDataDateStr + ' 12:00:00'),
            new Date(bikeDataDateStr + ' 14:00:00'),
            new Date(bikeDataDateStr + ' 16:00:00'),
            new Date(bikeDataDateStr + ' 18:00:00'),
            new Date(bikeDataDateStr + ' 20:00:00'),
            new Date(bikeDataDateStr + ' 22:00:00')
          ];

          let x_axis = graph_elems
            .append('g')
            .attr("id", "x_axis")
            .attr("transform", "translate(0," + graph_height + ")")
            .call(d3.axisBottom(x)
              .tickValues(x_axis_ticks)
              .tickFormat(d3.timeFormat("%-I %p")))
            .selectAll("text")
            .style("text-anchor", "end")
            .attr("dx", "-.8em")
            .attr("dy", ".15em")
            .attr("transform", "rotate(-65)");

          // add y axis
          let y = d3.scaleLinear()
            .domain([y_val_min, y_val_max])
            .range([graph_height, graph_height]); // start with all points collapsed on the bottom axis (they will animate to the correct location upon load)

          let y_axis = graph_elems
            .append('g')
            .attr("id", "y_axis")
            .call(d3.axisLeft(y));

          // format data for appropriate display
          function formatData(rowOfData) {

            // parse all dates in data set as the appropriate date objects
            rowOfData.starttime = parseDatetime(rowOfData.starttime);

            // set their corresponding day as the first of the month (that way all
            // data points fall within same 24h period and constitute a 'typical
            // day')
            rowOfData.starttime.setDate(1);

            // convert all values for tripduration to minutes from seconds
            rowOfData.tripduration = rowOfData.tripduration / 60;
          }
          bike_data.forEach(formatData);

          // filter the data to ensure none go outside the ranges of the axes
          function filterToWithinAxesRange(data) {
            return data.filter(function(point) {
              return point.starttime >= x_val_min && point.starttime <= x_val_max && point.tripduration >= y_val_min && point.tripduration <= y_val_max;
            });
          }
          bike_data = filterToWithinAxesRange(bike_data);

          // binding data
          let data_points = graph_elems
            .selectAll("data_points")
            .data(bike_data)
            .enter()
            .append("circle")
            .attr("cx", function(d) {
              return x(d.starttime)
            })
            .attr("cy", function(d) {
              return y(d.tripduration)
            })
            .attr("class", "data_point")
            .attr("fill", "rgb(63,72,204)")
            .attr("r", 1);

          // animate data points to travel to their y-coordinate location from the bottom
          // by first adjusting the range of the y-axis
          y.range([graph_height, 0]);

          chart_background.select("#y_axis")
            .transition()
            .duration(500)
            .call(d3.axisLeft(y));

          // transition the points to their correct location
          data_points
            .transition()
            .delay(function(d, i) {
              // delay proportional to the number of seconds from the start of
              // the day
              let secsFromStart = (60 * 60 * d.starttime.getHours()) + (60 * d.starttime.getMinutes()) + d.starttime.getSeconds()
              return (secsFromStart / 10)
            })
            .duration(2000)
            .attr("cx", function(d) {
              return x(d.starttime);
            })
            .attr("cy", function(d) {
              return y(d.tripduration);
            })

        })
        .catch((error) => {
          console.error("Error loading the data");
        });
    }

    // generate a scatter plot for each sample of blue bike data (corresponding
    // to one day from each season)
    generateScatterAnim("201909-bluebikes-tripdata.csv", false);

    //    generateScatterAnim("201901-bluebikes-tripdata.csv", true);
    //    generateScatterAnim("201902-bluebikes-tripdata.csv", true);
    //    generateScatterAnim("201903-bluebikes-tripdata.csv", true);
    //    generateScatterAnim("201904-bluebikes-tripdata.csv", true);
    //    generateScatterAnim("201905-bluebikes-tripdata.csv", true);
    //    generateScatterAnim("201906-bluebikes-tripdata.csv", true);
    //    generateScatterAnim("201907-bluebikes-tripdata.csv", true);
    //    generateScatterAnim("201908-bluebikes-tripdata.csv", true);
    //    generateScatterAnim("201909-bluebikes-tripdata.csv", true);
    //    generateScatterAnim("201910-bluebikes-tripdata.csv", true);
    //    generateScatterAnim("201911-bluebikes-tripdata.csv", true);
    //    generateScatterAnim("201912-bluebikes-tripdata.csv", true);
  </script>
</body>

</html>