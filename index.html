<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Blue Bikes</title>
  <script src="https://d3js.org/d3.v6.js"></script>
</head>

<body>

  <!-- div that will contain visualization -->
  <div id="chart_area"></div>

  <script>
    // function to generate a scatter plot, given the name of an accessible csv
    // file with appropriately formatted data
    function generateScatter(csvFileName) {

      // define a parser for parsing csv columns representing datetimes (but
      // formatted as strings) as the appropriate date objects
      let parseDatetime = d3.timeParse("%Y-%m-%d %H:%M:%S");

      // define a datetime formatter for formmatting a date object in a way that is
      // cleanly readable as a date (specifically, "June 30, 2015")
      let formatDatetime = d3.timeFormat("%A, %B %d, %Y");

      // infer the date the bike data is describing based on the file name and
      // store this as a set of useful variables
      let bikeDataDateStr = csvFileName.substring(13, 23);
      let bikeDataDate = parseDatetime(bikeDataDateStr + ' 00:00:00');

      // set padding and spacing
      let chart_area_padding = {
          top: 70,
          right: 30,
          bottom: 70,
          left: 65
        },

        chart_area_width = 460,
        chart_area_height = 400,
        graph_width = chart_area_width - chart_area_padding.left - chart_area_padding.right,
        graph_height = chart_area_height - chart_area_padding.top - chart_area_padding.bottom;

      // set min and max values for axes
      let x_val_min = parseDatetime(bikeDataDateStr + ' 0:00:00'),
        x_val_max = parseDatetime(bikeDataDateStr + ' 23:59:59'),
        y_val_min = 0,
        y_val_max = 120;

      let chart_area = d3.select("#chart_area")
        .attr("id", "chart_area")

      // add chart background
      let chart_background = chart_area
        .append("svg")
        .attr("id", "chart_background")
        .attr("width", chart_area_width)
        .attr("height", chart_area_height)
        .attr("style", "background: lightgrey");

      // add chart title
      chart_background.append("text")
        .attr("text-anchor", "middle")
        .attr("x", (graph_width / 2) + chart_area_padding.left)
        .attr("y", 30)
        .text("Bluebike Trip Duration By Time Of Day");

      // add chart subtitle
      chart_background.append("text")
        .attr("text-anchor", "middle")
        .attr("x", (graph_width / 2) + chart_area_padding.left)
        .attr("y", 50)
        .attr("font-size", 11)
        .text("(All  Rides in Boston, Cambridge, Brookline, Somerville on " + formatDatetime(bikeDataDate));

      // add x-axis label
      chart_background.append("text")
        .attr("text-anchor", "middle")
        .attr("x", (graph_width / 2) + chart_area_padding.left)
        .attr("y", graph_height + chart_area_padding.top + 56)
        .text("Trip Start Time");

      // add y-axis label
      chart_background.append("text")
        .attr("text-anchor", "middle")
        .attr("transform", "rotate(-90)")
        .attr("y", chart_area_padding.left / 2 - 5)
        .attr("x", -chart_area_padding.top - graph_height / 2)
        .text("Trip Duration (Minutes)")

      // add  group that will contain chart elements
      let graph_elems = chart_background
        .append("g")
        .attr("id", "graph_elems")
        .attr("transform", "translate(" + chart_area_padding.left + "," + chart_area_padding.top + ")");

      // read data
      d3.csv(csvFileName).then((bike_data) => {

          // add x axis
          let x = d3.scaleLinear()
            .domain([x_val_min, x_val_max])
            .range([0, graph_width]);

          // specify where want x-axis tick marks placed
          let x_axis_ticks = [
            new Date(bikeDataDateStr + ' 02:00:00'),
            new Date(bikeDataDateStr + ' 04:00:00'),
            new Date(bikeDataDateStr + ' 06:00:00'),
            new Date(bikeDataDateStr + ' 08:00:00'),
            new Date(bikeDataDateStr + ' 10:00:00'),
            new Date(bikeDataDateStr + ' 12:00:00'),
            new Date(bikeDataDateStr + ' 14:00:00'),
            new Date(bikeDataDateStr + ' 16:00:00'),
            new Date(bikeDataDateStr + ' 18:00:00'),
            new Date(bikeDataDateStr + ' 20:00:00'),
            new Date(bikeDataDateStr + ' 22:00:00')
          ];

          let x_axis = graph_elems
            .append('g')
            .attr("id", "x_axis")
            .attr("transform", "translate(0," + graph_height + ")")
            .call(d3.axisBottom(x)
              .tickValues(x_axis_ticks)
              .tickFormat(d3.timeFormat("%-I %p")))
            .selectAll("text")
            .style("text-anchor", "end")
            .attr("dx", "-.8em")
            .attr("dy", ".15em")
            .attr("transform", "rotate(-65)");

          // add y axis
          let y = d3.scaleLinear()
            .domain([y_val_min, y_val_max])
            .range([graph_height, graph_height]); // start with all points collapsed on the bottom axis (they will animate to the correct location upon load)

          let y_axis = graph_elems
            .append('g')
            .attr("id", "y_axis")
            .call(d3.axisLeft(y));

          // parse all dates in data set as the appropriate date objects
          function parseDates(rowOfData) {
            rowOfData.tripStartTime = parseDatetime(rowOfData.tripStartTime);
          }
          bike_data.forEach(parseDates);

          // convert all values for tripDuration to minutes from seconds
          function convertDurToMin(rowOfData) {
            rowOfData.tripDuration = rowOfData.tripDuration / 60;
          }
          bike_data.forEach(convertDurToMin);

          // filter the data to ensure none go outside the ranges of the axes
          function filterToWithinAxesRange(data) {
            return data.filter(function(point) {
              return point.tripStartTime >= x_val_min && point.tripStartTime <= x_val_max && point.tripDuration >= y_val_min && point.tripDuration <= y_val_max;
            });
          }

          bike_data = filterToWithinAxesRange(bike_data);

          // binding data
          let data_points = graph_elems
            .selectAll("data_points")
            .data(bike_data)
            .enter()
            .append("circle")
            .attr("cx", function(d) {
              return x(d.tripStartTime)
            })
            .attr("cy", function(d) {
              return y(d.tripDuration)
            })
            .attr("class", "data_point")
            .attr("fill", "rgb(63,72,204)")
            .attr("r", 1);

          // animate data points to travel to their y-coordinate location from the bottom
          // by first adjusting the range of the y-axis
          y.range([graph_height, 0]);

          chart_background.select("#y_axis")
            .transition()
            .duration(500)
            .call(d3.axisLeft(y));

          // transition the points to their correct location
          data_points
            .transition()
            .delay(function(d, i) {
              return (i)
            })
            .duration(2000)
            .attr("cx", function(d) {
              return x(d.tripStartTime);
            })
            .attr("cy", function(d) {
              return y(d.tripDuration);
            })

        })
        .catch((error) => {
          console.error("Error loading the data");
        });
    }

    // generate a scatter plot for each sample of blue bike data (corresponding
    // to one day from each season)
    generateScatter("bluebikedata_2020-09-01.csv");
    generateScatter("bluebikedata_2019-12-03.csv");
    generateScatter("bluebikedata_2020-03-03.csv");
    generateScatter("bluebikedata_2020-06-02.csv");
  </script>
</body>

</html>